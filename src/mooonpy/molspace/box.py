# -*- coding: utf-8 -*-
"""
@author: Josh Kemppainen
Revision 1.0
June 15, 2025
Michigan Technological University
1400 Townsend Dr.
Houghton, MI 49931

@author: Tristan Muzzy
Revision 1.1
July 5, 2025
"""
from typing import Union, Optional, List, Tuple


class Box:
    """
    Class representing a restricted triclimic simulation box as described in LAMMPS docs.
    mooonpy uses this geometry internally, and will write tilt factors if any are nonzero
    https://docs.lammps.org/Howto_triclinic.html


    ..todo::
        - read in from general triclinic to restricted
    """

    def __init__(self, **kwargs):
        self.xlo: float = -0.5
        self.xhi: float = 0.5
        self.ylo: float = -0.5
        self.yhi: float = 0.5
        self.zlo: float = -0.5
        self.zhi: float = 0.5
        self.yz: float = 0.0
        self.xz: float = 0.0
        self.xy: float = 0.0

        for key, value in kwargs.items():
            setattr(self, key, value)

    def get_lengths(self) -> Tuple[float, float, float]:
        """
        Compute box lengths from box edges.

        :return: lengths of box edges
        :rtype: Tuple[float, float, float]
        """
        lx = self.xhi - self.xlo
        ly = self.yhi - self.ylo
        lz = self.zhi - self.zlo
        return lx, ly, lz

    def get_transformation_matrix(self) -> Tuple[list[float], list[float], list[float], list[float]]:
        """
        Generate transformation matrix to convert to and from fractional 
        or Cartesian coordinates using LAMMPS "sparse matrix" setup.

        >>> matrix = [[lx, xy, xz],
        >>>           [0 , ly, yz],
        >>>           [0 ,  0, lz]]
        >>> matrix_index = [[0  , 5, 4],
        >>>                 [na , 1, 3],
        >>>                 [na ,na, 2]]
        >>> h = [lx, ly, lz, yz, xz, xy]
        >>> h_inv = matrix^-1 # indexing the same locations
        >>> boxlo = [xlo, ylo, zlo]
        >>> boxhi = [xhi, yhi, zhi]

        :return: Tuple corresponding to transformation matrix, inverse matrix, low and high box vectors
        :rtype: Tuple[List[float],List[float],List[float],List[float]]
        """
        lx, ly, lz = self.get_lengths()
        h = [lx, ly, lz, self.yz, self.xz, self.xy]
        h_inv = 6 * [0]
        h_inv[0] = 1 / h[0]
        h_inv[1] = 1 / h[1]
        h_inv[2] = 1 / h[2]
        h_inv[3] = -h[3] / (h[1] * h[2])
        h_inv[4] = (h[3] * h[5] - h[1] * h[4]) / (h[0] * h[1] * h[2])
        h_inv[5] = -h[5] / (h[0] * h[1])

        # General box parameters
        boxlo = [self.xlo, self.ylo, self.zlo]
        boxhi = [self.xhi, self.yhi, self.zhi]
        return h, h_inv, boxlo, boxhi

    def pos2frac(self, x, y, z, h_inv, boxlo) -> Tuple[float, float, float]:
        """
        Convert cartesian to fractional coords (0-1) for one atom

        >>> frac = h_inv*(x - x0)

        where frac is the fractional coordinate, x is the
        cartesian coordinate, and x0 is the origin of the
        simulation cell in that direction and h_inv is the sparse
        inverse matrix of h, generated by get_box_parameters(m).

        :param x: X Cartesian coordinate
        :type x: float
        :param y: Y Cartesian coordinate
        :type y: float
        :param z: Z Cartesian coordinate
        :type z: float
        :param h_inv: Inverse matrix of h as 6 components
        :type h_inv: List[float]|Tuple[float,float,float,float,float,float]
        :param boxlo: Low box vector
        :type boxlo: List[float]|Tuple[float,float,float]
        """
        # Align atoms with origin of simulation cell
        dx = x - boxlo[0]
        dy = y - boxlo[1]
        dz = z - boxlo[2]

        # Convert to fractional coords
        frac_x = h_inv[0] * dx + h_inv[5] * dy + h_inv[4] * dz
        frac_y = h_inv[1] * dy + h_inv[3] * dz
        frac_z = h_inv[2] * dz
        return frac_x, frac_y, frac_z

    def frac2pos(self, frac_x, frac_y, frac_z, h, boxlo) -> Tuple[float, float, float]:
        """
        Convert fractional (0-1) to cartesian coords for one atom

        >>> x = h*frac + x0

        where frac is the fractional coordinate, x is the
        cartesian coordinate vector, and x0 is the origin of the
        simulation cell in that direction and h is the sparse
        h matrix, generated by get_box_parameters(m).

        :param frac_x: X fractional coordinate
        :type frac_x: float
        :param frac_y: Y fractional coordinate
        :type frac_y: float
        :param frac_z: Z fractional coordinate
        :type frac_z: float
        :param h: Matrix of h as 6 components
        :type h: List[float]|Tuple[float,float,float,float,float,float]
        :param boxlo: Low box vector
        :type boxlo: List[float]|Tuple[float,float,float]

        .. todo::
            - Change docs to use LaTeX
        """
        pos_x = h[0] * frac_x + h[5] * frac_y + h[4] * frac_z + boxlo[0]
        pos_y = h[1] * frac_y + h[3] * frac_z + boxlo[1]
        pos_z = h[2] * frac_z + boxlo[2]
        return pos_x, pos_y, pos_z


if __name__ == "__main__":
    box = Box()
